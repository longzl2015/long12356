---

title: 自动化配置

date: 2018-09-01 11:24:00

categories: [springboot]

tags: [springboot,自动化配置,AutoConfigure]

---

springboot 自动化配置注解 EnableAutoConfiguration

<!--more-->

## @EnableAutoConfiguration

首先是从@SpringBootApplication开始的，这个注解是一个组合注解，其中包含@EnableAutoConfiguration注解

```java

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({EnableAutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
    Class<?>[] exclude() default {};

    String[] excludeName() default {};
}
```

观察@EnableAutoConfiguration可以发现，这里Import了@EnableAutoConfigurationImportSelector，这就是Spring Boot自动化配置的“始作俑者”

EnableAutoConfigurationImportSelector 中较为重要的代码片段如下

```java
	/**
	 * 返回 自动化配置类 的类名 
	 * Return the auto-configuration class names that should be considered. By default
	 * this method will load candidates using {@link SpringFactoriesLoader} with
	 * {@link #getSpringFactoriesLoaderFactoryClass()}.
	 * @param metadata the source metadata
	 * @param attributes the {@link #getAttributes(AnnotationMetadata) annotation
	 * attributes}
	 * @return a list of candidate configurations
	 */
	protected List<String> getCandidateConfigurations(AnnotationMetadata metadata,
			AnnotationAttributes attributes) {
		List<String> configurations = SpringFactoriesLoader.loadFactoryNames(
				getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
		Assert.notEmpty(configurations,
				"No auto configuration classes found in META-INF/spring.factories. If you "
						+ "are using a custom packaging, make sure that file is correct.");
		return configurations;
	}
	
    protected Class<?> getSpringFactoriesLoaderFactoryClass() {
        return EnableAutoConfiguration.class;
    }
	
    /**
    * 
    * FACTORIES_RESOURCE_LOCATION = META-INF/spring.factories
    *
     */
    public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {
        String factoryClassName = factoryClass.getName();
        try {
            Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
                    ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
            List<String> result = new ArrayList<String>();
            while (urls.hasMoreElements()) {
                URL url = urls.nextElement();
                Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));
                String factoryClassNames = properties.getProperty(factoryClassName);
                result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));
            }
            return result;
        }
        catch (IOException ex) {
            throw new IllegalArgumentException("Unable to load [" + factoryClass.getName() +
                    "] factories from location [" + FACTORIES_RESOURCE_LOCATION + "]", ex);
        }
    }
   
```
以上代码 主要就是使用Spring 4 提供的的SpringFactoriesLoader工具类。通过SpringFactoriesLoader.loadFactoryNames()读取了ClassPath下面的所有META-INF/spring
.factories文件（没错，是所有，也就意味着其他的starter也是在他们的jar包中定义META-INF/spring.factories文件，这样就可以让SpringBoot加载到，达到了自动化配置的目的，这也是自定义Starter的思路），并且指定了key为org.springframework.boot.autoconfigure.EnableAutoConfiguration.class


```properties
# org.springframework.cloud.starter.eureka.server 自动化配置

# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.cloud.starter.eureka.server.EurekaServerStarterDeprecationWarningAutoConfiguration
```

**小结**

通过@EnableAutoConfiguration启用Spring应用程序上下文的自动配置，这个注解会导入一个EnableAutoConfigurationImportSelector的类，而这个类会去读取classpath下所有的spring.factories下key为EnableAutoConfiguration对应的全限定名的值。

这个spring.factories里面配置的那些类，主要作用是告诉Spring Boot这个stareter所需要加载的那些xxxAutoConfiguration类（其实这个类的作用就是定义Bean，注册Bean）。然后，我们实现一个spring.factories指定的类，标上@Configuration注解，这样就形成了一个Starter

## 来源
https://blog.csdn.net/jeffleo/article/details/77173551