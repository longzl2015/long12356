---

title: kafaka架构和应用

date: 2018-09-28 14:04:00

categories: [kafka]

tags: [kafka]

---



kafka 是一个分布式流媒体系统(streaming platform)。

<!--more-->

一个 streaming platform 拥有3种能力:

- 发布、订阅 记录流，类似于消息队列和企业消息系统。
- 存储记录流，并具备容错和持久能力
- 当记录流产生时，能够对他们进行处理

kafka 主要用于两类应用:

- 在不同系统或者应用之间，构建实时流数据管道用获取可靠数据
- 构建实时流处理应用，用于转换或者响应流数据



## 基本概念

- kafka 是以集群的方式运行在一个或者多个服务器上。可以跨多个数据中心。
- kafka 以 topic 的形式储存记录流。
- 每一个记录包含 一个key、一个value 和 一个时间戳

## 4类API

![](kafaka架构和应用/kafka.png)

- Producer API: 允许应用将流记录发布到一个或多个kafka主题中
- Consumer API: 允许应用订阅一个或者多个kafka主题，并处理产生给它们的记录流
- Streams API: 允许应用作为一个流处理器, 消费来自一个或多个主题的输入流，产生送送至一个或多个主题的输出流，有效地将输入流转换为输出流。
- Connector API: 允许构建和运行可重用的生产者和消费者，其能够将kafka、存在的应用或数据库连接在一起。如 建立一个连接到关系型数据库的connector，能够捕捉每一个改变并将其存入表中。

在Kafka中，客户端和服务器之间的通信通过一个简单、高性能、语言无关的TCP协议完成。该协议版本化，并保持与旧版本的向后兼容性。我们为卡夫卡提供Java客户端，但客户端可以用多种语言提供。

## Topics and Logs

topic 代表发布的流记录的类别。在kafka中，topics通常拥有多个订阅者，也就是说 一个 topic 可以拥有 零个、一个或者多个消费者。

对于每一个topic，kafka集群维护着如下的分区日志:

![](kafaka架构和应用/分区日志.png)

每一个分区都是一个有序的、不可变的记录序列，记录被连续地追加到结构化提交日志中。
每个分区中的记录都被分配了一个序列ID号(offset)，该序列ID号唯一地标识分区内的每个记录。

无论记录是否被消费，所有已发布的记录会持久地保存在卡夫卡集群中，这个保存周期取决于配置的周期。
例如，如果保留策略设置为两天，那么在发布记录后的两天内，它可以用于消费，两天之后将被丢弃以释放空间。kafka的性能相对于数据大小是有效不变的，所以长时间存储数据不是问题。

![](kafaka架构和应用/d5f3b769.png)

事实上，每个消费者保存的唯一元数据是消费者在日志中的offset或者position。
这个偏移值是由消费者控制的：通常，消费者在读取记录时向后逐个偏移，但实际上，由于位置是由消费者控制的，所以它可以按照任何顺序使用记录。
比如，一个消费者可以将offset设为旧值 达到重新处理过期的数据 或者 直接跳过部分记录直接读取最近的记录。

这些特征的组合使得kafka集群消费者非常cheap: 他们可以随意的获取数据但不会影响其他的消费者。比如您可以使用命令行工具跟踪任何主题的内容，而不必更改任何现有消费者所消费的内容。

日志中的分区有多种用途: 

- 分区允许日志大小能够超出单个服务器所能提供的大小。每个分区必须位于单个服务器中，但是一个主题可以有多个分区，因此他可以处理任意大小的数据。
- 分区能够并行处理。

## Distribution

日志的分区分布在Kafka集群中的服务器上，每个服务器处理数据和请求分区。每个分区可以配置具体的容错份数。

每个分区都有一个“领导者”和零个或多个“追随者”。领导者处理所有的读写请求，而追随者被动复制的领导者。如果领导者失败，其中的一个追随者将自动成为新的领导者。每个服务器充当一些分区的领导者和其他人的追随者，因此集群内的负载很好地平衡。

## geo 复制

Kafka MirrorMaker 为您的集群提供地理复制支持。使用MirrorMaker，消息能够跨多个数据中心或云区域复制。您可以在主动/被动场景中使用此选项进行备份和恢复；或者在主动/主动场景中使用此选项来将数据放置得更靠近用户，或者支持数据局部性需求。

## 生产者

生产者将数据发布到指定的topic中。生产者可以决定将哪些记录分配到某一topic种的指定分区中。这可以通过特定的算法实现，如根据记录的某个key的hash值来确定某个分区。

## 消费者

消费者可以进行分组得到消费者组，发布到主题的某条记录，会被传递给订阅该主题的消费者组的某一个消费者实例。消费者实例可以在单独的进程中，也可以在单独的服务器中。

如果所有的消费者实例拥有相同的消费者组，那么记录将会在使用者实例中进行有效的均衡负载。
如果所有的消费者实例拥有不同的消费者组，那么记录会被广播给所有的消费者进程(???为什么是所有的).

![](kafaka架构和应用/9ec63bd8.png)

如上图所示，kafka集群中包含 2两个服务器(共管理4个分区(P0-P3)) 和 2组 消费者组。 消费者组A有2个消费者实例，消费者组B有4个。

一般情况下，topic有少量的消费者组，一个组一个“逻辑订阅者”。为了可扩展性和容错性，每个组由许多的消费者实例组成。这仅仅是发布订阅语义，其中订阅服务器是一组消费者而不是单个进程。

kafka消费方式的实现: 在消费者实例中划分日志中的分区，每个消费者实例专门处理分配给自己的分区。这个组的成员状态检测是由kafka自己动态处理的。
如果一个组加入了一个新的实例，新实例会接管其他成员的部分分区；如果某个实例挂了，他的分区会被其他的实例接管。



## 其他资料
https://blog.csdn.net/wjacketcn/article/details/50912878
https://kafka.apache.org/intro