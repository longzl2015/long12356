---
title: 垃圾回收-概述.md
date: 2016-03-21 21:03:34
tags: [垃圾回收,java]
categories: [语言,java,jvm]
---

[TOC]

垃圾回收相关知识

<!--more-->

## 判断对象存活的方式

### 引用计数法

引用计数法 主要缺点: 无法解决 循环依赖问题。

### 可达性分析算法

GC_ROOT:

Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多÷÷种）方式成为roots，否则它们并不是roots。
Thread - 活着的线程
Stack Local - Java方法的local变量或参数
JNI Local - JNI方法的local变量或参数
JNI Global - 全局JNI引用
Monitor Used - 用于同步的监控对象
Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此需要去确定哪些是属于"JVM持有"的了。


__引用类型__

1. 强引用：类似“object = new Object()”的引用
2. 软引用：SoftReference
3. 弱引用：WeakReference
4. 虚引用：PhantomReference

## 永久代的垃圾回收

### 废弃常量

没有任何String对象引用常量池中的“abc”，则abc为废弃常量

### 判断无用的类

1. java堆中不存在该类的实例
2. 加载该类的ClassLoader已经被回收
3. 该类对应的java.lang.Class对象没有在任何地方被引用。

## 垃圾收集算法

1. 标记清除算法：效率低，造成内存不连续
2. 复制算法：将内存容量分半，只用一半的内存。当一半内存用光时，将还存在的对象复制到里一半中，已使用的内存清空。
3. 标记整理算法：整理阶段，将存活的对象往前移。
4. 分代收集算法

## 垃圾收集器

1. serial收集器: 暂停所有工作线程，开始收集垃圾。（新生代-复制算法，老年代-标记和整理算法）。用于Client模式下的虚拟机。
2. Parnew收集器：serial的多线程版
4. CMS收集器：并发、低停顿。
	- 对CPU资源敏感
	- 无法处理浮动垃圾
	- 会形成空间碎片
3. G1收集器：并发、分代收集、空间整理、可预测的停顿