---
title: 单例模式.md
date: 2016-03-20 14:36:44
tags: [设计模式]
---

[TOC]

<!--more-->

## 懒汉式，线程不安全

这种方式是最简单的实现方式，能够实现懒加载。

最大的缺点：不支持多线程。

```java

public class Singleton {
    private static Singleton instance;
    private Singleton (){}

    public static Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
    }
}
```

## 懒汉式，线程安全

具备懒加载，同时由于有synchronized的存在，保证了线程安全。

缺点：加锁影响效率，任何时候只能有一个线程调用getInstance()。

```java
public class Singleton {
    private static Singleton instance;
    private Singleton (){}

    public static synchronized Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
    }
}
```

## 饿汉式，线程安全

利用classloader机制避免线程安全。

优点：没有加锁，效率高
缺点：不具备懒加载。对于依赖配置文件的单例类，这种方法无法完成。

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton (){}
    public static Singleton getInstance() {
    return instance;
    }
}
```

## 双重校验锁

采用双锁机制，安全且在多线程情况下能保持高性能

```java
public class Singleton {
    private volatile static Singleton singleton;
    private Singleton (){}
    public static Singleton getSingleton() {
    if (singleton == null) {
        synchronized (Singleton.class) {
        if (singleton == null) {
            singleton = new Singleton();
        }
        }
    }
    return singleton;
    }
}
```

## 静态内部类

使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。

```java
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton (){}
    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

```

## 枚举 Enum

创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象

```java
public enum EasySingleton{
    INSTANCE;
}
```


----
[单例模式](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)